# Generated by Claude Code on 2025-01-26
"""
Codebase State Manager for tracking file changes and managing incremental updates.

This module provides intelligent codebase loading with change detection to minimize
redundant processing and maintain optimal memory efficiency.
"""

import json
import os
import hashlib
import time
from pathlib import Path
from typing import Dict, List, Set, Optional, Tuple, Any
from dataclasses import dataclass, asdict
import logging

logger = logging.getLogger(__name__)


@dataclass
class FileManifestEntry:
    """Represents a file's state in the manifest."""
    path: str
    mtime: float
    size: int
    hash_md5: Optional[str] = None


@dataclass
class CodebaseManifest:
    """Manifest of the entire codebase state."""
    timestamp: float
    project_root: str
    total_files: int
    total_size: int
    files: Dict[str, FileManifestEntry]
    memignore_patterns_count: int
    filtering_method: str
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for JSON serialization."""
        return {
            'timestamp': self.timestamp,
            'project_root': self.project_root,
            'total_files': self.total_files,
            'total_size': self.total_size,
            'files': {path: asdict(entry) for path, entry in self.files.items()},
            'memignore_patterns_count': self.memignore_patterns_count,
            'filtering_method': self.filtering_method
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'CodebaseManifest':
        """Create manifest from dictionary."""
        files = {
            path: FileManifestEntry(**entry_data) 
            for path, entry_data in data['files'].items()
        }
        return cls(
            timestamp=data['timestamp'],
            project_root=data['project_root'],
            total_files=data['total_files'],
            total_size=data['total_size'],
            files=files,
            memignore_patterns_count=data['memignore_patterns_count'],
            filtering_method=data['filtering_method']
        )


@dataclass
class CodebaseChanges:
    """Represents detected changes in the codebase."""
    new_files: List[str]
    modified_files: List[str]
    deleted_files: List[str]
    total_changes: int
    
    @property
    def has_changes(self) -> bool:
        """Check if there are any changes."""
        return self.total_changes > 0


class CodebaseStateManager:
    """
    Manages codebase state tracking and change detection for optimal loading.
    
    Features:
    - Tracks file modification times and sizes
    - Detects new, modified, and deleted files
    - Generates manifest files for state persistence
    - Supports incremental updates
    """
    
    def __init__(self, project_root: str, manifest_filename: str = ".codebase_state.json"):
        """
        Initialize the codebase state manager.
        
        Args:
            project_root: Root directory of the project
            manifest_filename: Name of the manifest file to store state
        """
        self.project_root = Path(project_root).resolve()
        self.manifest_path = self.project_root / manifest_filename
        self.current_manifest: Optional[CodebaseManifest] = None
        
    def _calculate_file_hash(self, file_path: Path) -> str:
        """Calculate MD5 hash of a file for change detection."""
        try:
            hasher = hashlib.md5()
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hasher.update(chunk)
            return hasher.hexdigest()
        except Exception as e:
            logger.warning(f"Could not calculate hash for {file_path}: {e}")
            return ""
    
    def _scan_current_files(self, filtered_files: List[Path]) -> Dict[str, FileManifestEntry]:
        """
        Scan current files and create manifest entries.
        
        Args:
            filtered_files: List of files after .memignore filtering
            
        Returns:
            Dictionary of file paths to manifest entries
        """
        manifest_files = {}
        
        for file_path in filtered_files:
            try:
                if not file_path.exists():
                    continue
                    
                stat = file_path.stat()
                relative_path = str(file_path.relative_to(self.project_root))
                
                entry = FileManifestEntry(
                    path=relative_path,
                    mtime=stat.st_mtime,
                    size=stat.st_size,
                    hash_md5=None  # Calculate only if needed for change detection
                )
                
                manifest_files[relative_path] = entry
                
            except Exception as e:
                logger.warning(f"Error processing file {file_path}: {e}")
                continue
        
        return manifest_files
    
    def load_previous_manifest(self) -> Optional[CodebaseManifest]:
        """
        Load the previous codebase manifest if it exists.
        
        Returns:
            Previous manifest or None if not found/invalid
        """
        if not self.manifest_path.exists():
            logger.info("No previous codebase manifest found")
            return None
        
        try:
            with open(self.manifest_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
            
            manifest = CodebaseManifest.from_dict(data)
            logger.info(f"Loaded previous manifest: {manifest.total_files} files from {manifest.timestamp}")
            return manifest
            
        except Exception as e:
            logger.warning(f"Could not load previous manifest: {e}")
            return None
    
    def save_manifest(self, manifest: CodebaseManifest) -> bool:
        """
        Save the current manifest to disk.
        
        Args:
            manifest: Manifest to save
            
        Returns:
            True if saved successfully, False otherwise
        """
        try:
            with open(self.manifest_path, 'w', encoding='utf-8') as f:
                json.dump(manifest.to_dict(), f, indent=2)
            
            logger.info(f"Saved codebase manifest: {manifest.total_files} files")
            return True
            
        except Exception as e:
            logger.error(f"Could not save manifest: {e}")
            return False
    
    def detect_changes(self, current_files: List[Path], 
                      memignore_patterns_count: int,
                      filtering_method: str) -> Tuple[CodebaseChanges, CodebaseManifest]:
        """
        Detect changes between current state and previous manifest.
        
        Args:
            current_files: List of current filtered files
            memignore_patterns_count: Number of patterns applied
            filtering_method: Method used for filtering
            
        Returns:
            Tuple of (detected changes, current manifest)
        """
        # Scan current files
        current_manifest_files = self._scan_current_files(current_files)
        
        # Create current manifest
        current_manifest = CodebaseManifest(
            timestamp=time.time(),
            project_root=str(self.project_root),
            total_files=len(current_manifest_files),
            total_size=sum(entry.size for entry in current_manifest_files.values()),
            files=current_manifest_files,
            memignore_patterns_count=memignore_patterns_count,
            filtering_method=filtering_method
        )
        
        # Load previous manifest
        previous_manifest = self.load_previous_manifest()
        
        if previous_manifest is None:
            # No previous state, everything is new
            changes = CodebaseChanges(
                new_files=list(current_manifest_files.keys()),
                modified_files=[],
                deleted_files=[],
                total_changes=len(current_manifest_files)
            )
            logger.info(f"No previous manifest found. Full load required: {changes.total_changes} files")
            return changes, current_manifest
        
        # Compare manifests
        current_paths = set(current_manifest_files.keys())
        previous_paths = set(previous_manifest.files.keys())
        
        new_files = list(current_paths - previous_paths)
        deleted_files = list(previous_paths - current_paths)
        modified_files = []
        
        # Check for modifications in common files
        common_files = current_paths & previous_paths
        for file_path in common_files:
            current_entry = current_manifest_files[file_path]
            previous_entry = previous_manifest.files[file_path]
            
            # Compare modification time and size
            if (current_entry.mtime != previous_entry.mtime or 
                current_entry.size != previous_entry.size):
                modified_files.append(file_path)
        
        changes = CodebaseChanges(
            new_files=new_files,
            modified_files=modified_files,
            deleted_files=deleted_files,
            total_changes=len(new_files) + len(modified_files) + len(deleted_files)
        )
        
        # Log change summary
        if changes.has_changes:
            logger.info(f"Codebase changes detected: {len(new_files)} new, "
                       f"{len(modified_files)} modified, {len(deleted_files)} deleted")
        else:
            logger.info("No codebase changes detected since last load")
        
        return changes, current_manifest
    
    def should_reload_codebase(self, current_files: List[Path],
                             memignore_patterns_count: int,
                             filtering_method: str) -> Tuple[bool, CodebaseChanges, CodebaseManifest]:
        """
        Determine if codebase should be reloaded based on detected changes.
        
        Args:
            current_files: List of current filtered files
            memignore_patterns_count: Number of patterns applied
            filtering_method: Method used for filtering
            
        Returns:
            Tuple of (should_reload, changes, current_manifest)
        """
        changes, current_manifest = self.detect_changes(
            current_files, memignore_patterns_count, filtering_method
        )
        
        should_reload = changes.has_changes
        
        if should_reload:
            logger.info(f"Codebase reload required due to {changes.total_changes} changes")
        else:
            logger.info("Codebase is up to date, skipping reload")
        
        return should_reload, changes, current_manifest
    
    def mark_load_complete(self, manifest: CodebaseManifest) -> bool:
        """
        Mark codebase loading as complete by saving the manifest.
        
        Args:
            manifest: Manifest representing the loaded state
            
        Returns:
            True if marked successfully, False otherwise
        """
        self.current_manifest = manifest
        return self.save_manifest(manifest)
    
    def get_files_for_incremental_update(self, changes: CodebaseChanges) -> List[str]:
        """
        Get list of files that need to be processed for incremental update.
        
        Args:
            changes: Detected changes
            
        Returns:
            List of file paths that need processing
        """
        files_to_process = []
        files_to_process.extend(changes.new_files)
        files_to_process.extend(changes.modified_files)
        
        return files_to_process
    
    def get_files_for_deletion(self, changes: CodebaseChanges) -> List[str]:
        """
        Get list of files that need to be removed from memory.
        
        Args:
            changes: Detected changes
            
        Returns:
            List of file paths that need to be removed
        """
        return changes.deleted_files