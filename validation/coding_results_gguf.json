[
  {
    "prompt_id": "function_generation_001",
    "category": "function_generation",
    "complexity": "basic",
    "prompt_text": "Write a Python function named calculate_factorial that takes an integer n and returns its factorial. Include a docstring with parameter and return value descriptions.",
    "generated_code": "Okay, I need to write a Python function called calculate_factorial that takes an integer n and returns its factorial. Let me think about how to approach this. \n\nFirst, I remember that the factorial of a number n is the product of all positive integers up to n. So for example, 5! is 5 × 4 × 3 × 2 × 1 = 120. \n\nBut wait, what if the input is a negative number? Oh right, the factorial is only defined for non-negative integers. So I should probably check if the input is a non-negative integer. If it's not, maybe return an error or a special value. But the problem statement says to write a function that takes an integer n, so maybe the input is guaranteed to be a non-negative integer. The problem statement doesn't specify, but I should handle possible edge cases. \n\nSo the steps I need to take are:\n\n1. Check if n is a non-negative integer. If not, return 1 or some error value. Wait, but the problem says to return the factorial. So perhaps the input is guaranteed to be a non-negative integer. Let me check the problem statement again. The user says, \"Write a Python function named calculate_factorial that takes an integer n and returns its factorial.\" So maybe the input is a non-negative integer. So I can proceed under that assumption.\n\nSo the function will take n as input, compute n! and return it. \n\nNow, how to compute the factorial. Well, for small n, a loop is straightforward. For example, initialize a result variable as 1, then multiply it by each integer from 1 up to n. \n\nBut wait, what if n is 0? Then the factorial is 1. So the base case is when n is 0, return 1. For n=1, return 1. For n>1, multiply from 1 to n. \n\nSo the code structure would be:\n\ndef calculate_factorial(n):\n    if n < 0:\n        return 1  # Wait, no. If n is negative, factorial isn't defined. So maybe return 1? Or maybe raise an error. But the problem says to return the factorial. So perhaps the input is a non-negative integer. So maybe the code can assume that n is a non-negative integer. \n\nWait, the problem statement says \"takes an integer n\". So maybe the input can be any integer, but the function should return the factorial",
    "latency_ms": 14887.396097183228,
    "peak_memory_mb": 2586.5,
    "memory_before_mb": 2577.890625,
    "memory_after_mb": 2586.5,
    "token_count_input": 26,
    "token_count_output": 392,
    "success": true,
    "error_message": null,
    "syntax_valid": false
  },
  {
    "prompt_id": "code_completion_001",
    "category": "code_completion",
    "complexity": "basic",
    "prompt_text": "Complete the following Python class method get_full_name:\n\nclass User:\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n\n    def get_full_name(self):\n        # TODO: Complete this method",
    "generated_code": "To complete the `get_full_name` method in the `User` class, you need to concatenate the `first_name` and `last_name` attributes and return the resulting string. Here's how you can do it:\n\n```python\nclass User:\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n\n    def get_full_name(self):\n        return f\"{self.first_name} {self.last_name}\"\n```\n\nThis method takes the `first_name` and `last_name` attributes, concatenates them with a space in between, and returns the resulting string. The `f` string formatting is used to ensure that the output is properly formatted with the correct spacing.",
    "latency_ms": 3989.812135696411,
    "peak_memory_mb": 2587.28125,
    "memory_before_mb": 2586.515625,
    "memory_after_mb": 2587.28125,
    "token_count_input": 28,
    "token_count_output": 86,
    "success": true,
    "error_message": null,
    "syntax_valid": false
  },
  {
    "prompt_id": "docstring_generation_001",
    "category": "docstring_generation",
    "complexity": "basic",
    "prompt_text": "Add a PEP 257 compliant docstring to the following Python function:\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
    "generated_code": "<think>\n\nHere's the Python function with a PEP 257 compliant docstring:\n\n```python\ndef is_prime(n):\n    \"\"\"\n    Checks if a number is prime.\n\n    Args:\n        n (int): The number to be checked for primality.\n\n    Returns:\n        bool: True if the number is prime, False otherwise.\n\n    Raises:\n        ValueError: If n is less than 2.\n\n    Examples:\n        >>> is_prime(5)\n        True\n        >>> is_prime(4)\n        False\n        >>> is_prime(1)\n        Traceback (most recent call last):\n            ...\n        ValueError: n must be greater than or equal to 2\n    \"\"\"\n    if n < 2:\n        raise ValueError(\"n must be greater than or equal to 2\")\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n```\n\nThe docstring follows PEP 257 guidelines, which include:\n\n1. A one-line summary of the function's purpose.\n2. A description of the function's arguments and their types.\n3. A description of the function's return value.\n4. A description of any exceptions raised by the function.\n5. Examples of how to use the function.\n\nIn this case, the docstring includes:\n\n1. A one-line summary of the function's purpose: \"Checks if a number is prime.\"\n2. A description of the function's arguments and their types: \"n (int): The number to be checked for primality.\"\n3. A description of the function's return value: \"bool: True if the number is prime, False otherwise.\"\n4. A description of any exceptions raised by the function: \"Raises: ValueError: If n is less than 2.\"\n5. Examples of how to use the function: \"Examples: >>> is_prime(5) True >>> is_prime(4) False >>> is_prime(1) Traceback (most recent call last): ... ValueError: n must be greater than or equal to 2\"\n\nNote that the docstring also includes a ValueError exception for the case where n is less than 2, as this is a common edge case that should be handled.",
    "latency_ms": 12304.774761199951,
    "peak_memory_mb": 2589.125,
    "memory_before_mb": 2587.28125,
    "memory_after_mb": 2589.125,
    "token_count_input": 38,
    "token_count_output": 295,
    "success": true,
    "error_message": null,
    "syntax_valid": false
  },
  {
    "prompt_id": "refactoring_001",
    "category": "simple_refactoring",
    "complexity": "basic",
    "prompt_text": "Refactor the following Python code to use a list comprehension:\n\nsquares = []\nfor i in range(10):\n    squares.append(i*i)",
    "generated_code": "The provided Python code uses a `for` loop to generate a list of squares of numbers from 0 to 9. To refactor this code using a list comprehension, we can replace the `for` loop with a list comprehension that accomplishes the same task.\n\nHere's the refactored code:\n\n```python\nsquares = [i*i for i in range(10)]\n```\n\nThis list comprehension works by iterating over the range of numbers from 0 to 9 (inclusive), squaring each number, and appending the result to the `squares` list. The resulting list `squares` will contain the squares of numbers from 0 to 9.\n\nFor example, if you run this code, the output will be:\n\n```python\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n\nThis list comprehension is a concise and readable way to generate the same list of squares as the original `for` loop.",
    "latency_ms": 5595.107078552246,
    "peak_memory_mb": 2589.15625,
    "memory_before_mb": 2589.125,
    "memory_after_mb": 2589.15625,
    "token_count_input": 20,
    "token_count_output": 141,
    "success": true,
    "error_message": null,
    "syntax_valid": false
  },
  {
    "prompt_id": "bug_detection_001",
    "category": "bug_detection",
    "complexity": "basic",
    "prompt_text": "Identify and fix the bug in this Python function:\n\ndef find_item(items, target):\n    for item in items:\n        if item = target:  # Bug is here\n            return True\n    return False",
    "generated_code": "The bug in the provided Python function is the incorrect use of the assignment operator (=) instead of the equality operator (==) in the condition `if item = target:`. This is a common mistake in programming, often referred to as a \"typo\" or \"syntax error\" in the context of the assignment operator. \n\nThe correct condition should be `if item == target:`. This ensures that the function correctly checks if the current item in the list matches the target value. If the condition is met, the function returns `True`, indicating that the target item has been found. If the loop completes without finding the target, the function returns `False`.\n\nHere's the corrected version of the function:\n\n```python\ndef find_item(items, target):\n    for item in items:\n        if item == target:\n            return True\n    return False\n```\n\nThis correction ensures that the function correctly identifies the target item and returns the appropriate result.",
    "latency_ms": 5158.545017242432,
    "peak_memory_mb": 2589.15625,
    "memory_before_mb": 2589.15625,
    "memory_after_mb": 2589.15625,
    "token_count_input": 30,
    "token_count_output": 148,
    "success": true,
    "error_message": null,
    "syntax_valid": false
  },
  {
    "prompt_id": "algorithm_implementation_001",
    "category": "algorithm_implementation",
    "complexity": "intermediate",
    "prompt_text": "Implement a Python function called binary_search that takes a sorted list and a target value, then returns the index of the target or -1 if not found. Include proper error handling and a comprehensive docstring.",
    "generated_code": "Sure, here's a Python function that implements the binary search algorithm:\n\n```python\ndef binary_search(sorted_list, target):\n    \"\"\"\n    Performs a binary search on a sorted list to find the index of a target value.\n\n    Args:\n        sorted_list (list): A sorted list of elements.\n        target (any): The value to search for.\n\n    Returns:\n        int: The index of the target value if found, otherwise -1.\n    \"\"\"\n    # Handle empty list\n    if not sorted_list:\n        return -1\n\n    # Initialize left and right pointers\n    left = 0\n    right = len(sorted_list) - 1\n\n    # Perform binary search\n    while left <= right:\n        mid = (left + right) // 2\n        if sorted_list[mid] == target:\n            return mid\n        elif sorted_list[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    # If target not found, return -1\n    return -1\n```\n\nThis function takes a sorted list and a target value as input, and returns the index of the target value if found, or -1 if not found. It includes proper error handling by checking if the input list is empty before performing the binary search. The function uses the `//` operator for integer division to ensure that the mid index is always an integer.\n\nHere's an example usage:\n\n```python\nsorted_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 5\nindex = binary_search(sorted_list, target)\nprint(f\"Target {target} found at index {index}\")\n```\n\nOutput:\n```\nTarget 5 found at index 4\n```\n\nIf the target value is not found, the function will return -1:\n\n```python\nsorted_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]\ntarget = 10\nindex = binary_search(sorted_list, target)\nprint(f\"Target {target} found at index {index}\")\n```\n\nOutput:\n```\nTarget 10 found at index -1\n```\n\nNote that this implementation assumes that the input list is sorted in ascending order. If the list is not sorted, the binary search algorithm will not work correctly.",
    "latency_ms": 13416.279792785645,
    "peak_memory_mb": 2590.671875,
    "memory_before_mb": 2589.15625,
    "memory_after_mb": 2590.671875,
    "token_count_input": 37,
    "token_count_output": 307,
    "success": true,
    "error_message": null,
    "syntax_valid": false
  },
  {
    "prompt_id": "data_structure_001",
    "category": "data_structure_implementation",
    "complexity": "intermediate",
    "prompt_text": "Create a Python class called Stack that implements a basic stack data structure with push, pop, peek, and is_empty methods. Include type hints and proper error handling for empty stack operations.",
    "generated_code": "Sure, here's a Python class definition for a Stack data structure with the specified methods and error handling:\n\n```python\nfrom typing import Any\n\nclass Stack:\n    def __init__(self):\n        self.stack = []\n\n    def push(self, item: Any) -> None:\n        \"\"\"Pushes an item onto the stack.\"\"\"\n        self.stack.append(item)\n\n    def pop(self) -> Any:\n        \"\"\"Pops an item from the stack.\"\"\"\n        if not self.stack:\n            raise IndexError(\"Stack is empty.\")\n        return self.stack.pop()\n\n    def peek(self) -> Any:\n        \"\"\"Returns the top item on the stack without removing it.\"\"\"\n        if not self.stack:\n            raise IndexError(\"Stack is empty.\")\n        return self.stack[-1]\n\n    def is_empty(self) -> bool:\n        \"\"\"Checks if the stack is empty.\"\"\"\n        return not self.stack\n\n# Example usage:\nstack = Stack()\nstack.push(1)\nstack.push(2)\nprint(stack.peek())  # Output: 2\nprint(stack.pop())   # Output: 2\nprint(stack.is_empty())  # Output: False\nstack.pop()\nprint(stack.is_empty())  # Output: True\n```\n\nThis class definition includes type hints for the `push`, `pop`, `peek`, and `is_empty` methods, ensuring that the correct types are passed to the methods. The `__init__` method initializes an empty stack. The `push` method appends an item to the stack. The `pop` method raises an `IndexError` if the stack is empty. The `peek` method returns the top item on the stack without removing it, also raising an `IndexError` if the stack is empty. The `is_empty` method checks if the stack is empty and returns a boolean value.",
    "latency_ms": 9968.647003173828,
    "peak_memory_mb": 2590.6875,
    "memory_before_mb": 2590.6875,
    "memory_after_mb": 2590.6875,
    "token_count_input": 33,
    "token_count_output": 211,
    "success": true,
    "error_message": null,
    "syntax_valid": false
  },
  {
    "prompt_id": "string_processing_001",
    "category": "string_processing",
    "complexity": "intermediate",
    "prompt_text": "Write a Python function called validate_email that takes a string and returns True if it's a valid email format, False otherwise. Use regular expressions and handle edge cases like empty strings.",
    "generated_code": "def validate_email(email):\n    \"\"\"\n    Validates an email address using regular expressions.\n    \n    Args:\n        email (str): The email address to validate.\n    \n    Returns:\n        bool: True if the email is valid, False otherwise.\n    \"\"\"\n    import re\n    \n    # Regular expression pattern for a valid email address\n    pattern = r'^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'\n    \n    # Check if the email matches the pattern\n    if re.match(pattern, email):\n        return True\n    else:\n        return False\n\n# Example usage:\nemail = \"<EMAIL>\"\nprint(validate_email(email))  # Output: True\n\nempty_email = \"\"\nprint(validate_email(empty_email))  # Output: False",
    "latency_ms": 4672.739028930664,
    "peak_memory_mb": 2590.6875,
    "memory_before_mb": 2590.6875,
    "memory_after_mb": 2590.6875,
    "token_count_input": 33,
    "token_count_output": 76,
    "success": true,
    "error_message": null,
    "syntax_valid": true
  },
  {
    "prompt_id": "file_operations_001",
    "category": "file_operations",
    "complexity": "intermediate",
    "prompt_text": "Create a Python function called read_csv_safely that reads a CSV file and returns its contents as a list of dictionaries. Include proper exception handling for file not found, permission errors, and malformed CSV data.",
    "generated_code": "def read_csv_safely(file_path):\n    try:\n        with open(file_path, 'r') as file:\n            csv_data = file.read()\n            if csv_data.startswith('[') and csv_data.endswith(']'):\n                csv_data = csv_data[1:-1]\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'')\n                csv_data = csv_data.replace('\\'', '\"')\n                csv_data = csv_data.replace('\\\"', '\\'",
    "latency_ms": 15210.087299346924,
    "peak_memory_mb": 2592.25,
    "memory_before_mb": 2590.71875,
    "memory_after_mb": 2592.25,
    "token_count_input": 36,
    "token_count_output": 170,
    "success": true,
    "error_message": null,
    "syntax_valid": false
  },
  {
    "prompt_id": "async_programming_001",
    "category": "async_programming",
    "complexity": "advanced",
    "prompt_text": "Write an async Python function called fetch_urls that takes a list of URLs and returns their HTTP status codes concurrently. Use aiohttp and include proper error handling for network timeouts and invalid URLs.",
    "generated_code": "Here's a Python function that fetches the HTTP status codes for a list of URLs concurrently using aiohttp:\n\n```python\nimport asyncio\nimport aiohttp\n\nasync def fetch_urls(urls):\n    async with aiohttp.ClientSession() as session:\n        tasks = []\n        for url in urls:\n            task = asyncio.create_task(fetch_url(session, url))\n            tasks.append(task)\n        responses = await asyncio.gather(*tasks)\n        return [response.status for response in responses]\n\nasync def fetch_url(session, url):\n    try:\n        async with session.get(url) as response:\n            return response\n    except (aiohttp.ClientError, asyncio.TimeoutError) as e:\n        print(f\"Error fetching {url}: {e}\")\n        return None\n\n# Example usage:\nurls = [\"https://example.com\", \"https://example2.com\", \"https://example3.com\"]\nstatus_codes = asyncio.run(fetch_urls(urls))\nprint(status_codes)\n```\n\nThis function uses `asyncio` and `aiohttp` to fetch the HTTP status codes for a list of URLs concurrently. It first creates a `ClientSession` and then creates a list of `asyncio.create_task` objects, each fetching a URL. The `asyncio.gather` function waits for all tasks to complete and returns a list of responses. The function also includes error handling for `aiohttp.ClientError` and `asyncio.TimeoutError` exceptions.",
    "latency_ms": 9050.209045410156,
    "peak_memory_mb": 2592.359375,
    "memory_before_mb": 2592.359375,
    "memory_after_mb": 2592.359375,
    "token_count_input": 35,
    "token_count_output": 150,
    "success": true,
    "error_message": null,
    "syntax_valid": false
  }
]