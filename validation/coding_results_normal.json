{
  "model_info": {
    "model_path": "smollm",
    "device": "mps",
    "model_type": "normal_smollm3"
  },
  "test_summary": {
    "total_tests": 10,
    "successful_tests": 9,
    "syntax_valid_tests": 5,
    "average_latency_ms": 15986.723641500019,
    "max_latency_ms": 22213.72641700009,
    "average_peak_memory_mb": 1149.9109375,
    "max_peak_memory_mb": 1600.1875,
    "latency_under_200ms": 0,
    "memory_under_10gb": 10
  },
  "test_results": [
    {
      "prompt_id": "function_generation_001",
      "category": "function_generation",
      "complexity": "basic",
      "prompt_text": "Write a Python function named calculate_factorial that takes an integer n and returns its factorial. Include a docstring with parameter and return value descriptions.",
      "generated_code": "Ensure your solution handles edge cases such as negative numbers or non-integer inputs.\n\nExample:\n```python\nprint(calculate_factorial(5))  # Output: 120\n```\n\nAnswer:\n\ndef calculate_factorial(n):\n    \"\"\"\n    Calculate the factorial of a given integer.\n\n    Parameters:\n    n (int): The input integer for which to calculate the factorial.\n\n    Returns:\n    int: The factorial of the input integer.\n    \"\"\"\n\n    if not isinstance(n, int) or n < 0:\n        raise ValueError(\"Input must be a positive integer.\")\n\n    result = 1\n    for i in range(2, n + 1):\n        result *= i\n\n    return result",
      "latency_ms": 22213.72641700009,
      "peak_memory_mb": 1379.875,
      "memory_before_mb": 112.65625,
      "memory_after_mb": 1379.875,
      "token_count_input": 29,
      "token_count_output": 143,
      "success": true,
      "error_message": null,
      "syntax_valid": true
    },
    {
      "prompt_id": "code_completion_001",
      "category": "code_completion",
      "complexity": "basic",
      "prompt_text": "Complete the following Python class method get_full_name:\n\nclass User:\n    def __init__(self, first_name, last_name):\n        self.first_name = first_name\n        self.last_name = last_name\n\n    def g...",
      "generated_code": "user1 = User(\"John\", \"Doe\")\nprint(user1.get_full_name())\n# <NAME>\n\nuser2 = User(\"Jane\", \"Smith\")\nprint(user2.get_full_name())\n# <NAME>",
      "latency_ms": 4251.433291000012,
      "peak_memory_mb": 1600.0625,
      "memory_before_mb": 1573.546875,
      "memory_after_mb": 1600.0625,
      "token_count_input": 56,
      "token_count_output": 45,
      "success": true,
      "error_message": null,
      "syntax_valid": true
    },
    {
      "prompt_id": "docstring_generation_001",
      "category": "docstring_generation",
      "complexity": "basic",
      "prompt_text": "Add a PEP 257 compliant docstring to the following Python function:\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            ret...",
      "generated_code": "The docstring should explain what this function does and how it works.\n\nAnswer:\n\nHere's an example of a PEP 257-compliant docstring for the given Python function:\n\n```python\n\"\"\"\nThis function checks whether a given number 'n' is prime or not.\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n\nThe function takes one argument: 'n', which must be an integer.\n\nIf 'n' is less than or equal to 1, the function returns False, as per the definition of a prime number.\n\nOtherwise, the function iterates over all numbers from 2 up to the square root of 'n'. If any of these numbers divide 'n' evenly (i.e., leave no remainder), then 'n' is not a prime number. Otherwise, 'n' is considered a prime number.\n\nThe function returns a boolean value: True if 'n' is prime, and False otherwise",
      "latency_ms": 21622.05037500007,
      "peak_memory_mb": 1600.1875,
      "memory_before_mb": 1600.1875,
      "memory_after_mb": 661.5625,
      "token_count_input": 66,
      "token_count_output": 200,
      "success": true,
      "error_message": null,
      "syntax_valid": false
    },
    {
      "prompt_id": "refactoring_001",
      "category": "simple_refactoring",
      "complexity": "basic",
      "prompt_text": "Refactor the following Python code to use a list comprehension:\n\nsquares = []\nfor i in range(10):\n    squares.append(i*i)",
      "generated_code": "The correct refactor is:\n```\n>>> squares = [i*i for i in range(10)]\n```",
      "latency_ms": 2070.838832999925,
      "peak_memory_mb": 832.546875,
      "memory_before_mb": 832.546875,
      "memory_after_mb": 773.578125,
      "token_count_input": 29,
      "token_count_output": 23,
      "success": true,
      "error_message": null,
      "syntax_valid": false
    },
    {
      "prompt_id": "bug_detection_001",
      "category": "bug_detection",
      "complexity": "basic",
      "prompt_text": "Identify and fix the bug in this Python function:\n\ndef find_item(items, target):\n    for item in items:\n        if item = target:  # Bug is here\n            return True\n    return False",
      "generated_code": "The function takes a list of items (items) and a target value. It iterates through each item in the list using a `for` loop. The condition inside the `if` statement checks if an item equals the target value (`item = target`). However, this comparison is not correct because it uses the assignment operator (=) instead of the equality operator (==). This will always evaluate to `True`, regardless of whether the item actually matches the target.\n\nTo fix this issue, change the comparison from `item = target` to `item == target`. \n\nCorrected code:\n```python\ndef find_item(items, target):\n    for item in items:\n        if item == target:\n            return True\n    return False\n```\nNow, when you call this function with valid input, it should work as expected. If you provide incorrect inputs or a bug-free implementation, your task would be different.",
      "latency_ms": 17071.74629100018,
      "peak_memory_mb": 1022.640625,
      "memory_before_mb": 771.171875,
      "memory_after_mb": 1022.71875,
      "token_count_input": 43,
      "token_count_output": 186,
      "success": true,
      "error_message": null,
      "syntax_valid": true
    },
    {
      "prompt_id": "algorithm_implementation_001",
      "category": "algorithm_implementation",
      "complexity": "intermediate",
      "prompt_text": "Implement a Python function called binary_search that takes a sorted list and a target value, then returns the index of the target or -1 if not found. Include proper error handling and a comprehensive...",
      "generated_code": "Test your implementation with various inputs to ensure it works as expected.\n\nAnswer:\n\ndef binary_search(sorted_list, target):\n    \"\"\"\n    Searches for a target value in a sorted list using the Binary Search algorithm.\n    \n    Args:\n        sorted_list (list): A sorted list of elements.\n        target (any): The target element to search for.\n        \n    Returns:\n        int: The index of the target element if found, otherwise -1.\n    \"\"\"\n    low = 0\n    high = len(sorted_list) - 1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        \n        # Check if target is at the middle index\n        if sorted_list[mid] == target:\n            return mid\n        \n        # If target is less than the middle element, search left half\n        elif sorted_list[mid] > target:\n            high = mid - 1\n            \n        # If target is greater than the middle element, search right half\n        else:",
      "latency_ms": 18295.029749999685,
      "peak_memory_mb": 1147.6875,
      "memory_before_mb": 1147.6875,
      "memory_after_mb": 930.21875,
      "token_count_input": 41,
      "token_count_output": 200,
      "success": true,
      "error_message": null,
      "syntax_valid": false
    },
    {
      "prompt_id": "data_structure_001",
      "category": "data_structure_implementation",
      "complexity": "intermediate",
      "prompt_text": "Create a Python class called Stack that implements a basic stack data structure with push, pop, peek, and is_empty methods. Include type hints and proper error handling for empty stack operations.",
      "generated_code": "Provide example usage code to demonstrate the functionality of your Stack class.\n\n```python\nfrom typing import Any\n\n\nclass Stack:\n    def __init__(self) -> None:\n        self.items = []\n\n    def push(self, item: Any) -> None:\n        \"\"\"Add an element to the top of the stack\"\"\"\n        self.items.append(item)\n\n    def pop(self) -> Any:\n        \"\"\"Remove and return the last added element from the stack (LIFO)\"\"\"\n        if not self.is_empty():\n            return self.items.pop()\n        raise ValueError(\"Stack is empty\")\n\n    def peek(self) -> Any:\n        \"\"\"Return the last added element without removing it from the stack\"\"\"\n        if not self.is_empty():\n            return self.items[-1]\n        raise ValueError(\"Stack is empty\")\n\n    def is_empty(self) -> bool:\n        \"\"\"Check if the stack contains no elements\"\"\"\n        return len(self.items) == 0\n\n# Example usage\nstack = Stack()\n\nprint(stack.peek())",
      "latency_ms": 18454.15462500023,
      "peak_memory_mb": 1121.296875,
      "memory_before_mb": 1121.296875,
      "memory_after_mb": 408.984375,
      "token_count_input": 37,
      "token_count_output": 200,
      "success": true,
      "error_message": null,
      "syntax_valid": false
    },
    {
      "prompt_id": "string_processing_001",
      "category": "string_processing",
      "complexity": "intermediate",
      "prompt_text": "Write a Python function called validate_email that takes a string and returns True if it's a valid email format, False otherwise. Use regular expressions and handle edge cases like empty strings.",
      "generated_code": "Input: A single string representing an email address.\nOutput: A boolean value indicating whether the input is a valid email.\n\nExample:\n```python\nvalidate_email(\"john.doe@example.com\")  # Should return True\nvalidate_email(\"invalid-email-address\")  # Should return False\n```\n\nNote: The regex pattern should be able to match common email formats such as `username@domain.extension`.\n\nAnswer:\n\ndef validate_email(email):\n    import re\n    \n    # Regular expression pattern for matching a valid email address\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    \n    # Check if the input is not empty\n    if not email:\n        return False\n    \n    # Match the email against the regular expression pattern\n    match = re.match(pattern, email)\n    \n    # If no match found or invalid email format, return False\n    if not match or len(match",
      "latency_ms": 18438.052792000235,
      "peak_memory_mb": 617.0625,
      "memory_before_mb": 617.0625,
      "memory_after_mb": 580.703125,
      "token_count_input": 36,
      "token_count_output": 200,
      "success": true,
      "error_message": null,
      "syntax_valid": true
    },
    {
      "prompt_id": "file_operations_001",
      "category": "file_operations",
      "complexity": "intermediate",
      "prompt_text": "Create a Python function called read_csv_safely that reads a CSV file and returns its contents as a list of dictionaries. Include proper exception handling for file not found, permission errors, and m...",
      "generated_code": "The input to the function should be the name of the CSV file (as a string) and it should return None if there are any issues.\n\nHere's an example:\n\n```python\nimport csv\n\ndef read_csv_safely(csv_filename):\n    try:\n        with open(csv_filename, 'r') as f:\n            reader = csv.DictReader(f)\n            result = [row for row in reader]\n    except FileNotFoundError:\n        print(\"File not found: \" + csv_filename)\n        return None\n    except PermissionError:\n        print(\"Permission error: \" + csv_filename)\n        return None\n    except Exception as e:\n        # Handle other exceptions here...\n        print(\"Unknown error occurred while reading file.\")\n        return None\n    \n    return result\n```\n\nTo use this function, you can call it like so:\n\n```python\nresult = read_csv_safely('example.csv')\nif result is not None:\n    print(result)\nelse:\n    print(\"There was an issue",
      "latency_ms": 18494.75941599985,
      "peak_memory_mb": 719.53125,
      "memory_before_mb": 719.53125,
      "memory_after_mb": 600.1875,
      "token_count_input": 42,
      "token_count_output": 200,
      "success": false,
      "error_message": "The input to the function should be the name of the CSV file (as a string) and it should return None if there are any issues.\n\nHere's an example:\n\n```python\nimport csv\n\ndef read_csv_safely(csv_filename):\n    try:\n        with open(csv_filename, 'r') as f:\n            reader = csv.DictReader(f)\n            result = [row for row in reader]\n    except FileNotFoundError:\n        print(\"File not found: \" + csv_filename)\n        return None\n    except PermissionError:\n        print(\"Permission error: \" + csv_filename)\n        return None\n    except Exception as e:\n        # Handle other exceptions here...\n        print(\"Unknown error occurred while reading file.\")\n        return None\n    \n    return result\n```\n\nTo use this function, you can call it like so:\n\n```python\nresult = read_csv_safely('example.csv')\nif result is not None:\n    print(result)\nelse:\n    print(\"There was an issue",
      "syntax_valid": false
    },
    {
      "prompt_id": "async_programming_001",
      "category": "async_programming",
      "complexity": "advanced",
      "prompt_text": "Write an async Python function called fetch_urls that takes a list of URLs and returns their HTTP status codes concurrently. Use aiohttp and include proper error handling for network timeouts and inva...",
      "generated_code": "Ensure your code is efficient, using as few resources as possible.\n\nExample:\n\n```python\nurls = [\n    \"https://example.com\",\n    \"https://invalid-url\",\n    \"https://another-example.com\"\n]\n\n# Expected output:\n# [200, None, 404]\n```\n\nNote: You can assume the aiohttp library is already imported into your environment.\n\nAnswer:\n\n```python\nimport asyncio\nimport aiohttp\n\nasync def fetch_url(url):\n    try:\n        async with aiohttp.ClientSession() as session:\n            response = await session.get(url)\n            return response.status\n    except Exception as e:\n        print(f\"Error fetching URL {url}: {e}\")\n        return None\n\nasync def fetch_urls(urls):\n    results = []\n    tasks = []\n    \n    for url in urls:\n        task = asyncio.create_task(fetch_url(url))\n        tasks.append(task)\n        \n    for task in tasks:\n        result = await task\n        if result!= None:\n            results",
      "latency_ms": 18955.444624999927,
      "peak_memory_mb": 1458.21875,
      "memory_before_mb": 763.671875,
      "memory_after_mb": 1458.21875,
      "token_count_input": 37,
      "token_count_output": 200,
      "success": true,
      "error_message": null,
      "syntax_valid": true
    }
  ]
}