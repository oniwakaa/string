# Generated by SmolLM3-3B on 2025-01-01
"""
Configuration Loader for MemOS GGUF Integration

This module provides utilities to load configuration from YAML files
with support for environment variable overrides.
"""

import os
import sys
import yaml
from pathlib import Path
from typing import Dict, Any, Optional
import re

# Add MemOS to Python path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'MemOS', 'src'))

try:
    from memos.log import get_logger
    logger = get_logger(__name__)
except ImportError:
    import logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)


class ConfigLoader:
    """
    Configuration loader that supports YAML files with environment variable overrides.
    """
    
    def __init__(self, config_path: str = "config.yaml"):
        """
        Initialize the configuration loader.
        
        Args:
            config_path (str): Path to the YAML configuration file
        """
        # Check if we should use runtime config from STRING_HOME
        self.string_home = self._get_string_home()
        if config_path == "config.yaml" and self.string_home:
            runtime_config = self.string_home / "config" / "runtime_config.yaml"
            if runtime_config.exists():
                self.config_path = runtime_config
                logger.info(f"Using runtime config from STRING_HOME: {runtime_config}")
            else:
                self.config_path = Path(config_path)
        else:
            self.config_path = Path(config_path)
        self.config = {}
        
    def load(self) -> Dict[str, Any]:
        """
        Load configuration from YAML file and apply environment variable overrides.
        
        Returns:
            Dict[str, Any]: Loaded and processed configuration
        """
        # Load base configuration from YAML
        self.config = self._load_yaml()
        
        # Resolve STRING_HOME placeholders in paths
        if self.string_home:
            self.config = self._resolve_string_home_paths(self.config)
        
        # Apply environment variable overrides
        self._apply_env_overrides()
        
        logger.info(f"Configuration loaded from {self.config_path}")
        return self.config
    
    def _load_yaml(self) -> Dict[str, Any]:
        """
        Load configuration from YAML file.
        
        Returns:
            Dict[str, Any]: Configuration from YAML file
        """
        if not self.config_path.exists():
            logger.warning(f"Config file not found: {self.config_path}. Using default configuration.")
            return self._get_default_config()
        
        try:
            with open(self.config_path, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f) or {}
            logger.info(f"Loaded configuration from {self.config_path}")
            return config
        except Exception as e:
            logger.error(f"Error loading config file {self.config_path}: {e}")
            logger.info("Using default configuration")
            return self._get_default_config()
    
    def _apply_env_overrides(self) -> None:
        """
        Apply environment variable overrides to the configuration.
        """
        # Environment variable mappings
        env_mappings = {
            'STRING_HOME': ['string_home'],  # Support for STRING_HOME override
            'GGUF_MODEL_PATH': ['model', 'model_path'],
            'GGUF_GPU_LAYERS': ['gguf_model', 'hardware', 'gpu_layers'],
            'GGUF_THREADS': ['gguf_model', 'hardware', 'threads'],
            'GGUF_MAX_TOKENS': ['model', 'generation', 'max_tokens'],
            'GGUF_TEMPERATURE': ['model', 'generation', 'temperature'],
            'GGUF_TOP_P': ['model', 'generation', 'top_p'],
            'GGUF_TOP_K': ['model', 'generation', 'top_k'],
            'GGUF_REPETITION_PENALTY': ['gguf_model', 'generation', 'repetition_penalty'],
            'GGUF_CONTEXT_LENGTH': ['model', 'generation', 'n_ctx'],
            'MEMOS_USER_ID': ['memos', 'user_id'],
            'MEMOS_TOP_K': ['memos', 'top_k'],
            'SERVICE_HOST': ['service', 'api', 'host'],
            'SERVICE_PORT': ['service', 'api', 'port'],
            'LOG_LEVEL': ['logging', 'level'],
            'QDRANT_STORAGE_PATH': ['storage', 'qdrant_storage'],
            'CODEBASE_STATE_PATH': ['storage', 'codebase_state'],
        }
        
        for env_var, config_path in env_mappings.items():
            env_value = os.getenv(env_var)
            if env_value is not None:
                self._set_nested_config(config_path, self._convert_env_value(env_value))
                logger.info(f"Applied environment override: {env_var} -> {'.'.join(config_path)}")
    
    def _set_nested_config(self, path: list[str], value: Any) -> None:
        """
        Set a nested configuration value using a path.
        
        Args:
            path (list[str]): Path to the configuration key
            value (Any): Value to set
        """
        current = self.config
        for key in path[:-1]:
            if key not in current:
                current[key] = {}
            current = current[key]
        current[path[-1]] = value
    
    def _convert_env_value(self, value: str) -> Any:
        """
        Convert environment variable string to appropriate type.
        
        Args:
            value (str): Environment variable value
            
        Returns:
            Any: Converted value
        """
        # Handle boolean values
        if value.lower() in ('true', 'false'):
            return value.lower() == 'true'
        
        # Handle None/null values
        if value.lower() in ('none', 'null', ''):
            return None
        
        # Try to convert to int
        try:
            return int(value)
        except ValueError:
            pass
        
        # Try to convert to float
        try:
            return float(value)
        except ValueError:
            pass
        
        # Return as string
        return value
    
    def _get_default_config(self) -> Dict[str, Any]:
        """
        Get default configuration when YAML file is not available.
        
        Returns:
            Dict[str, Any]: Default configuration
        """
        return {
            'memos': {
                'user_id': 'default_user',
                'session_id': 'default_session',
                'enable_textual_memory': True,
                'enable_activation_memory': False,
                'top_k': 5,
            },
            'gguf_model': {
                'model_path': './smollm-quantized/smollm-q4_K_M.gguf',
                'generation': {
                    'max_tokens': 512,
                    'temperature': 0.7,
                    'top_p': 0.9,
                    'top_k': 50,
                    'repetition_penalty': 1.1,
                    'remove_think_prefix': False,
                },
                'hardware': {
                    'gpu_layers': 0,
                    'threads': None,
                    'context_length': 16384,  # Increased from 2048 to better utilize model's training context
                },
                'loading': {
                    'auto_load': True,
                    'validate_on_load': True,
                },
            },
            'service': {
                'health_check': {
                    'enabled': True,
                    'endpoint': '/health',
                    'include_model_info': True,
                },
                'api': {
                    'host': '0.0.0.0',
                    'port': 8000,
                    'title': 'MemOS with GGUF Integration',
                    'description': 'A persistent service integrating MemOS memory layer with GGUF models',
                    'version': '1.0.0',
                },
            },
            'memory': {
                'retrieval': {
                    'enabled': True,
                    'top_k': 5,
                    'mode': 'fast',
                    'memory_types': ['All'],
                },
                'cube': {
                    'default_cube_id': 'default_cube',
                    'auto_create': True,
                },
            },
            'logging': {
                'level': 'INFO',
                'format': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            },
        }
    
    def get(self, path: str, default: Any = None) -> Any:
        """
        Get a configuration value using dot notation.
        
        Args:
            path (str): Dot-separated path to the configuration key
            default (Any): Default value if key is not found
            
        Returns:
            Any: Configuration value
        """
        keys = path.split('.')
        current = self.config
        
        try:
            for key in keys:
                current = current[key]
            return current
        except (KeyError, TypeError):
            return default
    
    def _get_string_home(self) -> Optional[Path]:
        """Get STRING_HOME directory path."""
        import platform
        
        # Check for environment override
        if "STRING_HOME" in os.environ:
            return Path(os.environ["STRING_HOME"]).resolve()
        
        # Platform-specific defaults
        system = platform.system().lower()
        if system == "windows":
            home_base = Path(os.environ.get("USERPROFILE", Path.home()))
            return home_base / ".string"
        else:
            # macOS and Linux
            return Path.home() / ".string"
    
    def _resolve_string_home_paths(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Recursively resolve {{STRING_HOME}} placeholders in configuration paths.
        
        Args:
            config (Dict[str, Any]): Configuration dictionary
            
        Returns:
            Dict[str, Any]: Configuration with resolved paths
        """
        if isinstance(config, dict):
            result = {}
            for key, value in config.items():
                result[key] = self._resolve_string_home_paths(value)
            return result
        elif isinstance(config, list):
            return [self._resolve_string_home_paths(item) for item in config]
        elif isinstance(config, str) and "{{STRING_HOME}}" in config:
            resolved_path = config.replace("{{STRING_HOME}}", str(self.string_home))
            return resolved_path
        else:
            return config


def load_config(config_path: str = "config.yaml") -> Dict[str, Any]:
    """
    Convenience function to load configuration.
    
    Args:
        config_path (str): Path to the YAML configuration file
        
    Returns:
        Dict[str, Any]: Loaded configuration
    """
    loader = ConfigLoader(config_path)
    return loader.load() 